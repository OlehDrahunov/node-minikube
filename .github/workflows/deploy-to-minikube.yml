name: Deploy to Minikube

on:
  push:
    branches: [ master ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-22.04
    env:
      IMAGE_NAME: devopshint/node-app
      # IMAGE_TAG will be set from commit sha to make image unique per run
      IMAGE_TAG: git-${{ github.sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up QEMU (for multi-arch, optional)
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx (optional, keeps builds consistent)
        uses: docker/setup-buildx-action@v3

      - name: Start Minikube
        id: minikube
        # pin the setup-minikube action to a released version
        uses: medyagh/setup-minikube@v0.0.20
        with:
          kubernetes-version: v1.30.0
          minikube-version: v1.33.1
          driver: docker
          # optionally enable addons like ingress, registry
          addons: |
            registry
            ingress

      - name: Show minikube & kubectl version
        run: |
          minikube version
          kubectl version --client --short
          minikube status

      - name: Build Docker image
        run: |
          docker build -t ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} .

      - name: Load image into Minikube
        run: |
          minikube image load ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}

      - name: Deploy to Minikube
        run: |
          # substitute IMAGE tag placeholder in manifest if present and apply
          if grep -q "\${IMAGE_TAG}" k8s-node-app.yaml; then
            sed "s|\${IMAGE_TAG}|${{ env.IMAGE_TAG }}|g" k8s-node-app.yaml > rendered-k8s.yaml
            kubectl apply -f rendered-k8s.yaml
          else
            # replace image with the built tag (safe fallback)
            kubectl set image -f k8s-node-app.yaml '*/nodejs-app'=${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} --local -o yaml | kubectl apply -f -
          fi
          kubectl rollout status deployment/nodejs-app --timeout=180s

      - name: Wait for pods to be ready
        run: kubectl wait --for=condition=ready pod -l app=nodejs-app --timeout=180s

      - name: Get service URL
        id: service_url
        run: |
          # Try to get a URL using minikube service; may return multiple lines â€” take first
          URL=$(minikube service nodejs-app --url --namespace=default | head -n1 || true)
          echo "url=$URL" >> $GITHUB_OUTPUT

      - name: Health check (HTTP)
        run: |
          if [ -z "${{ steps.service_url.outputs.url }}" ]; then
            echo "No service URL returned by minikube. Dumping resources for debug."
            kubectl get all -l app=nodejs-app -o wide
            kubectl describe pod -l app=nodejs-app
            kubectl logs -l app=nodejs-app --tail=200 || true
            exit 1
          fi

          echo "Checking ${ { steps.service_url.outputs.url } }"
          for i in {1..20}; do
            if curl -fsS "${{ steps.service_url.outputs.url }}" | grep -q "Hello World"; then
              echo "App responded"
              exit 0
            fi
            sleep 3
          done
          echo "App did not respond after retries"
          kubectl get pods -l app=nodejs-app -o wide
          kubectl describe pod -l app=nodejs-app
          kubectl logs -l app=nodejs-app --tail=200 || true
          exit 1

      - name: Debug on failure
        if: failure()
        run: |
          minikube status
          kubectl get all -l app=nodejs-app -o wide
          kubectl describe pod -l app=nodejs-app
          kubectl logs -l app=nodejs-app --tail=200 || true
